### 現状の課題

- **MVC は概ねできているが、Service の「ユースケース単位」の切り方が曖昧**
  - Controller から見ると「何をしてくれるメソッドか」は分かるが、1 つの Service に複数ユースケースやインフラ関心事（セッション更新など）が同居している。
  - 特に `GoalService` 周りでは、「画面ごとのユースケース」と「ドメインロジック」と「セッション制御」が混ざりやすい状態になっている。

- **トランザクション境界が学習目的から見てもやや広め**
  - 読み取り専用処理にも `@Transactional` が付いており、「どこが DB の一貫性境界か」がコードから判別しづらい。
  - 「更新系／参照系」の区別と `readOnly` の使い分けが、今後の学習テーマとして残っている。

- **Repository の戻り値が `null` ベースで、`Optional` による意図の表現が不足**
  - 「データが存在しない」場合を `null` で表現しており、`Optional<T>` を活用した設計に慣れる余地がある。
  - 学習者レベルとしては自然だが、「現場で通用する Java 8+ 流儀」という観点では改善余地がある。

- **日付／時刻ロジックが `now()` 直呼び出しでテストが書きにくい**
  - `UserProgressService` などで `LocalDate.now()` を直接呼んでおり、特定日付（7 日目、30 日目など）を前提としたテストが書きづらい。
  - 「テストしやすい設計」という観点を学ぶ題材として適している。

- **テストは良いスタートだが、最も仕様が複雑な領域はまだ薄い**
  - `BonusAwesomeService` には良いテストがある一方で、`GoalService` / `UserProgressService` 周りはテストが少なく、仕様バグに弱い。

---

### 理想的な設計（学習用 MVC アプリとして）

- **Controller から見て「1 メソッド呼べば 1 ユースケースが完結する」Service**
  - 画面や機能（目標登録、目標更新、一覧表示など）ごとに、Controller が呼ぶ Service メソッドがほぼ 1:1 になる。
  - Controller はパラメータの受け取りと View 名の決定に集中し、ビジネスロジックは Service に任せる構造がより明確になる。

- **Service 内で「ドメインロジック」と「インフラ（セッション・トランザクション）」をゆるく分離**
  - すべてを DDD で分割する必要はないが、「**純粋ロジック寄りのクラス／メソッド**」と「**周辺インフラと連携するクラス／メソッド**」がなんとなくでも分かれている状態を目指す。
  - これにより、MVC + レイヤードアーキテクチャの基本を押さえた上で、次のステップ（DDD など）にも進みやすくなる。

- **トランザクション境界がユースケース単位で明確**
  - 「DB を更新するユースケース」の入口メソッドにだけ `@Transactional` を付ける。
  - 読み取り専用処理は `readOnly = true` か非トランザクションとし、コードだけ見ても「どこが重たい処理なのか」がイメージしやすい。

- **`Optional` と `Clock` を使った、テストしやすく意図が明確なコード**
  - Repository が `Optional<T>` を返し、Service が `orElseThrow` / `orElse` 等で明示的に「見つからない場合」のポリシーを記述する。
  - 日付／時刻は `Clock` 経由で取得し、ユニットテストで任意の日付を簡単に再現できる。

- **仕様が複雑な箇所にテストが充実している**
  - ストリーク計算・ボーナス付与・目標達成判定など、ビジネスロジックのコアとなる部分にテストが増えている。
  - テストメソッド名やシナリオがそのまま仕様書のように読める状態を目指す。

---

### 具体的な修正方針

#### 1. セッション／キャッシュの責務を Web 層寄りに寄せる

- **やること**
  - `SessionManager` への直接依存を、できるだけ Controller（または Web 層）側に移す。
  - 例: `GoalService` がセッションフラグ（`hasUpdatedRecordCount` 等）まで更新している場合、
    - Service は「保存結果（`SaveResult`）やフラグ情報」を返すだけにする。
    - Controller 側で「保存結果に応じてセッションを更新する」ようにロジックを移す。
- **学習的な狙い**
  - 「Service は HTTP やセッションを知らないほうがよい」というレイヤードアーキテクチャの基本を体感する。

#### 2. Goal / Memo / ArticleStock 周りの Service をユースケース単位に整理

- **やること**
  - 今の `GoalService` のメソッドを、画面やユースケース単位で見直す。
    - 例: 「一覧表示用 DTO 準備」「詳細表示用 DTO 準備」「新規登録」「更新」「削除」「ダミーデータ登録」など。
  - 同様の構造を持つ `Memo` / `ArticleStock` についても、可能な範囲でパターンを揃える。
  - 必要に応じて、「インフラ寄り」を扱うクラス（アプリケーションサービス的な役割）と、「ドメインロジック寄り」のクラスをゆるく分ける。
- **学習的な狙い**
  - 「ユースケース単位で Service を設計する」感覚を身につけることで、MVC の Controller-Service 間の関係をより深く理解する。

#### 3. トランザクション境界の整理

- **やること**
  - 更新系ユースケース（登録・更新・削除など）の入口メソッドにだけ `@Transactional` を付ける。
  - 読み取り専用処理に付いている `@Transactional` は、
    - `@Transactional(readOnly = true)` に変更する、または
    - アノテーションを外し、必要であれば上位のユースケースメソッドで一括管理する。
- **学習的な狙い**
  - 「トランザクション境界をどこに置くか？」という実務でも重要なテーマを、自分のコードで試せるようにする。

#### 4. Repository で `Optional` を導入する

- **やること**
  - 例: `GoalRepository.findGoalByIds(int goalId, int userId)` の戻り値を `Optional<Goal>` に変更する。
  - Service 側で `orElseThrow` / `orElse(null)` / `ifPresentOrElse` 等を使って、「見つからない場合どうするか」を明示的に書く。
- **学習的な狙い**
  - `null` ではなく `Optional` で「値がない状態」を表現する、Java 8 以降の実務的なコーディングスタイルを身につける。

#### 5. `Clock` を導入して日付／時刻依存ロジックをテストしやすくする

- **やること**
  - `UserProgressService`, `BonusAwesomeService` など、`LocalDate.now()` / `LocalDateTime.now()` を直接呼んでいるクラスに `Clock` をコンストラクタインジェクションする。
  - コード内の `LocalDate.now()` / `LocalDateTime.now()` を `LocalDate.now(clock)` / `LocalDateTime.now(clock)` に置き換える。
  - テストでは `Clock.fixed(...)` を使って、「特定日付での挙動」を再現する。
- **学習的な狙い**
  - 「テストしやすいコードを書くために、外部環境（時間）を抽象化する」という考え方を身につける。

#### 6. 仕様が複雑な領域のテストを強化する

- **やること**
  - `UserProgressService` のストリーク計算・ボーナス付与のロジックを、小さなクラスやメソッドに切り出してユニットテストを書く。
  - `GoalService` 周りでは、
    - 重複タイトル検知
    - 目標達成状態変更時の日時付与
    - タグの紐づけ・削除  
    など、仕様がブレやすい部分を中心にテストシナリオを作る。
- **学習的な狙い**
  - 「どこにテストを書くべきか」を意識することで、コードを書く時点からテスト容易性を考える習慣をつける。

---

この順番で少しずつリファクタリングしていくことで、

- MVC の理解（Controller / Service / Repository の役割）
- Spring Boot / MyBatis の実務に近い使い方
- テストしやすい設計・トランザクション境界の意識

といったポイントを、現場でもそのまま通用する形で身につけていけるはずです。  
一気にすべてを DDD 化する必要はなく、まずは「MVC + レイヤードアーキテクチャの基本を、今のプロジェクトでしっかり体に染み込ませる」ことを目標に進めていくのがおすすめです。

